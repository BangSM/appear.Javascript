# 실행 컨텍스트
오늘은 조금.. 어려운.. 실행컨텍스트에 대해서 살펴볼게요. 이 글을 보시면 자바스크립트가 전반적으로 어떻게 돌아가는지 알 수 있으실거에요  
실행컨텍스트를 모르면 디버깅도 어렵고 코드를 활용하는 측면에서도 어려울 수 있으니 꼭 이해하고 넘어가셔야됩니다.   

## 실행컨텍스트란?
간단히 말해서 자바스크립트가 실헹될 때 생성되는 실행 단위를 실행 컨텍스트라고 부릅니다.

혹시 콜스택이라고 들어보셨나요??    
자바스크립트의 경우 함수를 실행하면 함수들이 차곡차곡 스택이란 곳에 쌓입니다.   

실행컨텍스트는 콜스택에 쌓이는 하나하나의 실행 정보에요!    

`"ECMAScript"` 에서는 실행 컨텍스트를 "실행 가능한 코드를 형상화하고 구분하는 추상적인 개념"이다라고 말하고 있습니다. 

> ECMA스크립트란?    
> ECMA스크립트(ECMAScript, ES)는 Ecma 인터내셔널의 ECMA-262 기술 규격에 정의된 표준화된 스크립트 프로그래밍 언어이다.

다시한번 쉽게 풀어말하자면, 일반적으로 우리는 함수로 실행 컨텍스트를 만들죠? 우리는 다 함수단위로 쪼개고 있으니까요!     
함수안에는 변수, 객체, 실행코드 등이 들어있잖아요?    
이 함수가 실행되면서 우리가 선언해놓은 (변수, 객체, 실행코드 + @)를 포함한 실행 컨텍스트가 생성이되고 이것들이 스택에 하나하나 쌓이는 것 입니다.

`"ECMAScript"` 에서는 실행 컨텍스트의 생성을 이렇게 표현했다고 해요
현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면, 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 넘어간다.   
라고 설명했는데요 이게 사실 저 문맥만보면 말이 너무 어려워서 저는 이해가 잘 안가더라구요.. 그래서 하나하나 천천히 살펴보죠

## 실행컨텍스트 생성과정
활성객체와 변수객체, 스코프 체인이 어떻게 생성되는지 살펴볼게요

```js
function add(num1, num2){
  var a = 1;
  var b = 2;
  
  function innerAdd(){
    return a+b;
  }
  return num1 + num2 + innerAdd();
}
add(2, 3); // 8
```
위 같은 함수를 하나 만들어서 실행 했을때 어떤일이 벌어지는지 한번 살펴볼게요

자바스크립트 엔진은 우리가 실행한 함수를 실행 시키기위해 해당 컨텍스트에서 실행에 필요한 여러가지 정보를 담을 객체를 생성해줘요 이걸 `활성객체` 라고 부릅니다.
이 활성객체에는 매개변수나 변수, 객체 등을 저장하고, 새로 만들어진 컨텍스트로 접근이 가능하게 해줍니다.   
접근이 가능한것은 엔진내부에서의 접근을 뜻하고요 사용자가 직접 접근을 할 순 없어요. 

### 1. arguments 객체
arguments 객체가 어떻게 생성되는지 보다 우리는 arguments가 뭔지를 먼저 살펴보겠습니다. 아직 설명드린적이 없죠?

자바스크립트에서는 함수를 호출할때 꼭 함수 형식에 맞춰 인자를 넘겨주지 않아도 에러 안뜨는거 알고계셨나요?    
```js
function add(num, num2){
  console.log(num + num2);
}
add(); // NaN
add(1); // NaN
add(1, 2); // 3
add(1, 2, 3); // 3
```
보셨죠!? 인자를 어떻게 넘기더라두 자바스크립트에서는 에러가 안나요 신기하죠 ㅎㅎ    
add() 와같이 인자를 넘겨주지않으면 undefined가 넘어가구요 인자가 초과할경우 add(1, 2, 3) 3이 무시됐었죠? 넘치는 인자는 무시해요    

그런데 위처럼 num, num2 라고 2개만 딱 받게 지정을 해놓았는데 만약 인자가 4개 5개가 될 수 도있다면 num, num2, num3 이렇게 쭉쭉 늘어나겠죠?    
200개가 되면 .. 인자가 200개가 들어올 수 있게 해줘야된다는건데 ... 이건 아닌거같아요 그쵸 .. 

그럴때 사용할 수 있는게 바로 arguments 입니다.

```js
function add(){ // 인자로 갯수 지정을 해주지않았죠 ?
  console.dir(arguments);  // arguments 안에 들어가있죠?
}
add(1, 2);
```

arguments에 유사배열 [0:1, 1:2], 길이 : length : 2, callee : 현재 참조중인 함수 (add())     
이렇게 들어가있는거 보이시죠? 우리가 넣어준 인자가 배열처럼 생겼지만 배열이아닌 (유사객체라고불러요) 형식으로 들어가있는게 보이시나요?

그럼 활용해볼까요? 1 ~ 5 까지 더해주는 함수를 만들어볼게요 arguments를 몰랐다면 5개의 인자를 써서했겠지만 우리는 arguments를 배웠어요 
```js
function add(){
  var result = 0;
  // arguments.forEach() 이런건 아쉽게 못써요 ㅠㅠ arguments는 유사배열이라서 배열이 아니에요
  for(var i = 0, max = arguments.length; i < max ; i += 1 ){
    result += arguments[i];
  }
  return result;
}
add(1, 2, 3, 4, 5); // 15
```
이런식으로 활용 하시면 됩니다 ~~ 

다시 돌아가서 실행컨텍스트의 arguments를 이야기해보자면     
실행컨텍스트안에 활성객체는 arguments 프로퍼티로 arguments객체를 참조해요! 함수안에서 arguments를 쓸 수 있는 이유겠죠?

### 2. 스코프 정보 생성
실행 컨텍스트가 생성되면 컨텍스트의 유효범위를 나타내는 스코프 정보를 생성을 한다고해요  
컨텍스트안에는 연결리스트와 유사한 공간이 있는데, 컨텍스트의 변수에 접근하려할때 이 리스트를 활용한다고해요      
만약 리스트에 찾는 변수가 없다면 정의되지 않은 변수로 판단을해 에러를 뱉어준다고합니다.    
이 리스트를 스코프 체인이라고 부르고 [[scope]] 프로퍼티로 참조됩니다. 

### 3. 변수 생성
실행 컨텍스트 내부에서 지역변수 생성이 이루어집니다. ECMAScript에서는 생성되는 변수를 정장하는 변수 객체를 언급하는데요   
변수객체가 우리가 앞에서 배운 활성객체와 같은 의미라고합니다. 변수객체 = 활성객체 같은 뜻이니 혼동하지 말아주세요.   
활성객체 안에서 호출된 함수 인자는 프로퍼티가 만들어지고 값이 할당됩니다. 값이 없다면 undefined로 넘어가겠죠??  
```js
function add(num, num2){
  var a = 0;
  var b = 2;
  console.log(num + num2 + a + b);
}
```
add()가 실행되면 변수 a, b가 생성됩니다. 이때 변수 a, b (앞에 이름을 말하는 것 입니다.)는 메모리에 올라가지는데요 이때는 값을 할당하지않아요    
앞에서 배운 변수 호이스팅 기억나시나요? var로 선언된 변수들이 끌어올려지고 그 안에는 undefined로 할당이되던 것 기억하시나요?   
초기화는 활성객체가 다 생성된 이후에 이루어집니다.
   
지금까지의 과정을 천천히 살펴보자면 

함수실행 -> 실행컨텍스트 생성 -> 활성객체 (arguments할당, [[scope]]체인, 변수메모리 할당(이때 값은 undefined), 함수가 있다면 함수 생성)     
위에 단계를 풀어서 써놓은 것입니다. 많이 복잡하지요 ㅠ??.. 

### 4. this 바인딩 
마지막 단계로 this 바인딩이 이루어지는데 this는 참조하는 객체가 없으면 전역객체를 바라봅니다.    

## 정리
1. 함수실행시 가장 처음으로 전역 컨텍스트 생성시킵니다. 그리고 함수가 호출될 때마다 해당 함수의 컨텍스트가 만들어집니다.
2. 실행 컨텍스트 생성 시 컨텍스트 안에 변수객체(arguments, variable), scope chain, this가 생성됩니다.
3. 실행 컨텍스트 생성 후 함수가 실행됩니다. 사용되는 변수들은 활성객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾습니다. 없으면 에러가 뜨겠죠?
4. 함수 실행이 마무리되면 해당 컨텍스트는 사라집니다. 페이지가 종료되면 전역 컨텍스트가 사라집니다. 

함수 실행이 마무리되면 컨텍스트가 사라진다고 했지만 계속 살려두는 방법이있습니다. 클로저를 이용하는 겁니다. 클로저는 다음시간에 다뤄볼게요
