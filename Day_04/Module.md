
## 전역변수를 피하는법
자바스크립트에서는 전역변수를 만드는 일은 지양하라고 하고있습니다. 왜일까요?? 그 이유는 변수가 섞일 수 있기 때문입니다. 섞인다는게 무슨 의미일까요?

```js
var a = 5;

function changeNum(){
	a = 8; // 전역의 a를 8로 바꿨어요
}
function changeNum2(){
	a = 3; // 전역의 a가 바뀐줄 모르고 전역의 a를 3으로 바꿨어요
}
changeNum();
changeNum2();
console.log(a); // 최종 a는 3
```
앞 포스트들에서도 이런 경우를 보신적 있으시죠? 변수는 메모리주소를 담고있는 녀석인데 그거를 여러곳에서 돌려쓰다보니 이런일이 벌어지는 거에요    

그럼 어떻게 해결할 수 있을까요?    
간단한 해결 방법은 전역 변수 대신 함수 안에 넣어 지역변수로 만드는 겁니다. 아니면 객체 안의 속성으로 만드는 방법도 있습니다.

### 네임 스페이스
말그대로 네임 스페이스입니다. 이름을 가진 공간을 만들어서 그 안에서 처리를 해주는거에요 
```js
var x = 5; // 전역 x

var obj = { // 네임스페이스
  x: 'local', // 네임스페이스 안에 x 
  y: function() {
    alert(this.x); // 객체안에서의 this는 obj 자신을 의미합니다. this.x = local 이겠죠?
  }
}
``` 
전역과 네임스페이스가 분리되었죠! 이제 obj란 네임스페이스 안에서는 마음대로 놀 수 있는거에요!
그런데 문제가 하나있습니다. 위 방법의 단점은 누군가 고의적으로 x와 y를 바꿀 수 있어요… 공개(public)되어있기 때문이죠..

```js
var obj = { // 네임스페이스
  x: 'local', 
  y: function() {
    alert(this.x); 
  }
}
obj.x = 'global'; // 누군가 obj안에있는 x를 장난으로 global로 바꿔버렸어요
obj.y();
```
우리가 나름 전역을 피하기위해 이렇게 네임스페이스라는 공간을 만들어서 내부에 넣어놨지만 public 하기때문에 누구든 건들 수 있다는 문제가 있습니다.

위의 방법은 너무 위험합니다. 이때 등장하는 개념이 캡슐화라는 개념인데요 private하다 라고해서 내부값들을 비공개로 두는 것 입니다.
리모콘이 하나 있다고 할게요 리모콘 내부는 저도 어떻게 동작하는지 모르겠지만 .. 많은 부속품들이 있겠죠? 만약 부속품들이 다 밖으로 나와있다면 애기들이 만져서 고장내는건 일상이겠죠?   
그거를 방지하기위해 플라스틱으로 감싸고 동작할 수 있는 버튼들만 밖으로 내보내 주었죠? 부품은 감싸고 말이죠 이게 캡슐화입니다.    
내부 부속품(변수, 배열, 객체 등 ..)을 감싸고 버튼(함수)를 내보냄으로써 내보낸 함수들을 통해 부속품을 동작, 조작할 수 있게 해주는 방식을 말합니다!  

### 캡슐화
그러면 어떻게 내부 변수들을 감쌀지 한번 볼까요?
```js
// function은 우리가 앞서 살펴본결과 외부에서는 function 내부로의 접근이 불가했어요 그걸 이용하는겁니다.
var privateFunc = function () { 
  var x = 'local'; 
  function gety() { // gety() 라는 함수는 내부변수 x = local을 알림창에 찍어주는 역할을 해요
    alert(x);
  }
  return { 
  	gety : gety // gety라는 이름으로 gety()를 내보내는 겁니다.
  };
};
var pF = privateFunc();
console.log(pF); // {Pgety: ƒ} 변수는 담겨져 있지않고 함수만 들어있는거 보이시나요? 우리가 함수만 return 해줬기 떄문이에요
```
위 같은 방법으로 변수를 숨길 수 있어요.

### 즉시실행함수
그런데 저는 var pF = privateFunc();와 같이 함수를 한번더 실행해서 pF에 담아주는거에 대한 귀찮음을 느꼈었습니다. 한번에 리턴받으면 얼마나 좋을까요?? 
즉시 실행함수를 사용하면 가능합니다. 기본적인 형태는 이렇습니다. 
```js
(function(){
	// 실행구문 
})(); // 선언과 동시에 실행이됩니다.

var pF = (function(){ 
	
})();
```
var pF = privateFunc(); 함수를 한번더 실행해서 리턴값을 pF에 넣어주는 것을 한번에 해줄 수 있는데요 
```js
var privateFunc = (function () { 
  var x = 'local'; 
  function gety() { // gety() 라는 함수는 내부변수 x = local을 알림창에 찍어주는 역할을 해요
    alert(x);
  }
  return { 
  	gety : gety // gety라는 이름으로 gety()를 내보내는 겁니다.
  };
})(); // 이런식으로 감싸주시면 됩니다.
console.log(privateFunc);  // {gety: ƒ} 
```
var pF = privateFunc() 이런식으로 한번더 함수를 실행시켜서 담아야되는 부분을 줄일 수 있었죠? 보기에도 훨씬좋고요!

위에 방법은 공개 변수가 없는 자바스크립트에 비공개 변수 기능을 만들어주기 떄문에. 이 패턴은 꼭 기억하고 있어야합니다!

## 팁 
https://jsfiddle.net/6ouygurx/

간단한 모듈패턴을 알려드리겠습니다.
```js
var Person = (function(){ // 리턴된 생성자함수를 Person 변수에 담고있습니다.
  function Person(name) { // 내부에 생성자 함수를 만들어줍니다.
    this.name = name;
  }
  Person.prototype.getName = function(){ // 생성자에 프로토타입 함수도 작성해주고요!
    console.log(this.name);
  };
  return Person; // 완성된 생성자함수를 밖으로 던져줍니다.
})(); // 즉시실행으로 감싸줍니다.
console.dir(Person);
```
위처럼 하나의 모듈을 간단하게 만들 수 있어요

또, 즉시실행을 사용하면 좋은점이 있는데요 JQuery에서는 $라는 표현을 사용하는거 알고계신가요?    
그런데 다른 라이브러리에서도 $를 쓴다면 $가 겹치겠죠? 그때 즉시실행함수로 경계를 나눌 수 있어요!   
```js
var Person = (function($){ // 여기서 $는 밖에서 넣어준 jQuery를 의미해요!
  // 내부의 $는 다 jQuery 입니다.
})(jQuery); // 실행부에 jQuery를 넣어줍니다.

var Toy = (function($){ // 여기서 $는 밖에서 넣어준 다른라이브러리 의미해요!
  // 내부의 $는 다른라이브러리 입니다.
})(다른라이브러리); // 실행부에 다른라이브러리 넣어줍니다.
```
이런식으로 사용할 수 있습니다. 위에 두개다 유용하니 참고해주세요!
